"""xmlFileToPrefGraphFileConverter.py

Functions for converting xml files representing CP-nets into files usable by minpreffbas_exact.py, as well as to add relative importance to CP-net files
Used to generate our data sets and make them readable, as mentioned in the "Data Set Generation" Section

Xml files are described at https://www.ece.iastate.edu/~gsanthan/crisner.html and are generated by https://cs.uky.edu/~goldsmit/papers/GeneratingCPnetCode.html

Note: the functions currently only work for binary variable CP-nets
"""

import random

"""# Helper Functions"""

#function to create a list of all possible assignments of variables
#each entry in the list (i.e. different assignment of variables) is a different node in the graph
#INPUT:
#   assignmentList: a list of all possible assignments of variables. assigned empty on the initial call and builds through recursive calls
#   curAssignmentStr: a string representing assignments of variables (i.e. 0010 means V0=0, V1=0, V2=1, ...). assigned "" on initial call
#   numVarsToAssign: the number of variables that need an assignment
#   optionVals: the values that each variable can be assigned (normally 0 & 1)
#RETURN: nothing. once this runs, the list in "assignmentList" will be filled out with all possible variable assignments
def genAssignmentArr(assignmentList, curAssignmentStr, numVarsToAssign, optionVals):
  if(len(curAssignmentStr) == numVarsToAssign):
    #we have assigned all variables and thus append the string to the list
    assignmentList.append(curAssignmentStr)
  else:
    for val in optionVals:
      genAssignmentArr(assignmentList, curAssignmentStr + str(val), numVarsToAssign, optionVals)   #each recursive call assigns another variable

  return #this function doesn't return anything

#function to fill out the assignmentToId dictionary by first making a list of all
#possible assignments of n variables with k evaluations each and then adding those to a dict
#INPUT:
#   assignmentDict: dictionary with assignments as keys and an integer representing their ID as a value
#   numVariables: the number of variables that need to be assigned
#   optionVals: a list of the possible values that a variable can evaluate to
def fillAssignmentDict(assignmentDict, numVariables, optionVals):
  assignmentArr = []
  genAssignmentArr(assignmentArr, "", numVariables, optionVals) #generate an array of all assignments

  #turn the array to a dictionary
  index = 0
  for assignment in assignmentArr:
    assignmentDict[assignment] = index
    index += 1

# Get a list of dominated assignments/outcomes that only differ in the relative importance variables
# Every level of recursion "fixes" one of the relatively less important variables to one of two variables
# INPUT:
#     assignments: dictionary mapping assignment IDs as keys to outcome strings
#     dominatedAssignments: list of outcomes that are dominated, will be filled up through the recursive calls
#     currAssignment: the string representing the current assignment/outcome, at the top level should only differ by one variable from the dominating assignment
#     relImportanceLeft: list of variables that are relatively less important but have not been assigned a fixed variable in the recursion list,
# RETURN: nothing, updates dominatedAssignments in place
def getDominatedAssignments(assignments, dominatedAssignments, currAssignment, relImportanceLeft):
  numRelImp = len(relImportanceLeft)
  print(currAssignment)
  # Base case: no more unassigned relative importance variables left, add the current assignment/outcome to the list of dominated
  if numRelImp == 0:
    dominatedAssignments.append(assignments[currAssignment])
  else:
    currRelImportanceVar = relImportanceLeft[numRelImp - 1]
    restRelImportance = relImportanceLeft.copy()
    restRelImportance.pop(numRelImp - 1)

    # Currently only works for binary domain variables, TODO: Make work with non-binary domains
    changedAssignment = list(currAssignment)
    changedAssignment[currRelImportanceVar] = '1'
    changedAssignment = ''.join(changedAssignment)
    getDominatedAssignments(assignments, dominatedAssignments, changedAssignment, restRelImportance)

    changedAssignment = list(currAssignment)
    changedAssignment[currRelImportanceVar] = '2'
    changedAssignment = ''.join(changedAssignment)
    getDominatedAssignments(assignments, dominatedAssignments, changedAssignment, restRelImportance)

"""# Convert One File"""

#function that takes the filepath of a single XML Pref file as input and convert
#it to a prefGraph file (textfile) that can be used to run the inconsistency removal functions on.
#NOTE THIS ONLY WORKS IF THE VALUES THAT VARIABLES CAN BE ASSIGNED ARE A SINGLE CHARACTER! (namely "assignment[variableID]", i.e. var domains are <10 TODO: FIX)
# INPUT:
#     inputFilename: the name of the input xml file
#     outputFilename: the name of the file to output the preference graph file to
# RETURN: nothing, prints and writes all graph data to the output file
def xmlPrefFileToPGFconverter(inputFilename, outputFilename):
  #READ INPUT FILE - put all the lines of the file into 'lines'
  with open(inputFilename, 'r') as file:
    lines = file.readlines()

  #INITIALIZE GLOBAL VARIABLES
  i = 0                     #keep track of the line of the file you are in
  edgesDict = {}
  numVariables = 0          #number of (assignable) variables in the preference graph
  numPrefs = 0              #number of preference statements
  varToId = {}              #maps variables to int ID's which are used to index it
  assignmentToId = {}       #maps assignments of all variables (corresponding to nodes in graph) to integer IDs
  varToEvals = {}           #maps variable names ('v0') to possible assignments ([0,1,...])

  print(len(lines))

  #Parse Variable Data
  while i < len(lines):
    line = lines[i].strip()

    # Start of new variable
    if line == "<PREFERENCE-VARIABLE>":
      # Setup variables
      numVariables += 1
      i += 1
      variable = ""
      possibleAssignments = []
      doneCurrVar = False        # Will be true once done with parsing current variable
      while not doneCurrVar:
        line = lines[i].strip()
        parts = line.split(">")
        # Store variable name
        if parts[0] == "<VARIABLE-NAME":
          variable = parts[1].split("<")[0]
          varToId[variable] = numVariables - 1
        # Add a possible variable value
        elif parts[0] == "<DOMAIN-VALUE":
          currVal = parts[1].split("<")[0]
          possibleAssignments.append(currVal)
        # End of current variable
        elif parts[0] == "</PREFERENCE-VARIABLE":
          varToEvals[variable] = possibleAssignments
          doneCurrVar = True
        # Move on to next line
        i += 1
    # Increase number of preference statements
    elif line == "<PREFERENCE-STATEMENT>":
      numPrefs += 1
      i += 1
    # Move on to next line
    else:
      i+=1

  print(varToEvals)
  print(varToId)

  #GENERATE ALL ASSIGNMENTS (all nodes of graph) in the assignmentToId dict
  fillAssignmentDict(assignmentToId, numVariables,  [1,2]) #TODO: instead of 1,2, this should take in a list of variable assignments based on the metadata parsed

  #PARSE PREFERENCES
  currPrefNum = -1
  currPrefId = -1             #variable to store the ID of the current preference statement we are looking at TODO: remove if we don't need it
  invVariableIds = []         #array to store the current invariant variables
  invVariableVals = []        #array to store the current invariant variables invariant values
  domOrder = []               #array to store the order of the dominance of the domain values
  relLessImpVarIDs = []       #array to store the current variables that are relatively less important
  i = 0                       #reset line tracker

  #Read preference statements and add the corresponding edges to the files
  while i < len(lines):
    line = lines[i].strip()

    if line == "<PREFERENCE-STATEMENT>":
      i += 1
      doneCurrStatement = False
      firstDom = True
      varCurPrefOver = ""
      currPrefNum += 1
      # Clear the previous preference statement data
      invVariableIds.clear()
      invVariableVals.clear()
      domOrder.clear()
      relLessImpVarIDs.clear()
      # Parse the statement
      while not doneCurrStatement:
        line = lines[i].strip()
        parts = line.split(">")
        # Read the preference ID
        if parts[0] == "<STATEMENT-ID":
          currPrefId = parts[1].split("<")[0]
        # Read the variable the preference is on
        elif parts[0] == "<PREFERENCE-VARIABLE":
          varCurrPrefOver = parts[1].split("<")[0]
        # Read the conditions of the statement
        elif parts[0] == "<CONDITION":
          currCond = parts[1].split("<")[0].split("=")
          invVariableIds.append(varToId[currCond[0]])
          invVariableVals.append(currCond[1])
        # Read the preference order of the statements
        elif parts[0] == "<PREFERENCE":
          currPrefOrder = parts[1].split("<")[0].split(":")
          # Note, this currently abuses the fact that the xml gives the dominance from most to least preferred values
          # Might want to change this in the future
          if firstDom:
            domOrder.append(currPrefOrder[0])
            firstDom = False
          domOrder.append(currPrefOrder[1])
        # Read the relatively less important variables
        elif parts[0] == "<REGARDLESS-OF":
          relLessImpVarIDs.append(varToId[parts[1].split("<")[0]])
        # End of statement, can add to graph
        elif parts[0] == "</PREFERENCE-STATEMENT":
          doneCurrStatement = True
          #TODO: DEAL WITH END OF STATEMENT
          # Currently only works with binary values
          domVarId = varToId[varCurrPrefOver]  # get the ID of the variable in the dominance relation
          dominatingVal = domOrder[0]      # the dominating val is prefered over the dominated val
          dominatedVal = domOrder[1]

          for assignment in assignmentToId: #go through all the assignments and create edges for the edge file
            allInvariantsMatch = True   #keeps track on whether all the invariants are satisfied
            for j in range(0,len(invVariableIds)):
              if assignment[invVariableIds[j]] != invVariableVals[j]:
                allInvariantsMatch = False  #we saw an invariant that doesn't match
            if allInvariantsMatch and assignment[domVarId] == dominatingVal: #check if the invariant variables match and the domination relation variable is the dominating value
              #get the id of the dominating assignment
              dominatingAssignmentId = assignmentToId[assignment]

              #get the id of the dominated assignment
              dominatedAssignment = list(assignment)  #turn to list for mutability
              dominatedAssignment[domVarId] = dominatedVal #change the value of the domination varaible from dominating val to dominated val
              dominatedAssignment = ''.join(dominatedAssignment)  #turn back to a string
              # dominatedAssignmentId = assignmentToId[dominatedAssignment] #get the ID of the assignment

              # get all dominated assignments due to relative importance
              dominatedAssignments = []
              getDominatedAssignments(assignmentToId, dominatedAssignments, dominatedAssignment, relLessImpVarIDs)
              # print("Dominated Assignments: ", dominatedAssignments)

              # Add the edges to the file
              for dominatedAssignmentId in dominatedAssignments:

                #create edge
                newEdge = "(" + str(dominatingAssignmentId) + "," + str(dominatedAssignmentId) + ")" #NOTE this makes edge point towards dominating assignment: dominatedAssignment->dominatingAssignment
                print(newEdge)
                print(assignment,dominatedAssignment)

                if newEdge in edgesDict:  #if the edge has already been made previously, just update the stakeholder string
                  newPrefList = list(edgesDict[newEdge]) #make list for mutability
                  newPrefList[currPrefNum] = '1'    #make the current stakeholder be an endorser of this edge
                  newPrefStr = ''.join(newPrefList) #make string again
                  edgesDict[newEdge] = newPrefStr    #update dictionary
                else: #otherwise the edge is new so add a new entry to the dict where the only stakeholder endorsing this edge is the current one
                  newPrefStr = list('0'*numPrefs)  #turn to list for mutability
                  newPrefStr[currPrefNum] = '1'
                  newPrefStr = ''.join(newPrefStr)    #turn list back into string
                  edgesDict[newEdge] = newPrefStr
        # Continue to next line
        i += 1
        # print(i)
      print("Preference Statement on variable ", varCurrPrefOver)
      print(invVariableIds)
      print(invVariableVals)
      print(domOrder)
    #Move on to next line
    else:
      i += 1
      # print(i)



  #DONE PARSING LINES, write all edges to output file
  with open(outputFilename, 'w') as f_out:
    print(assignmentToId)
    for edge in edgesDict:
      parsedEdge = ((edge.strip("(")).strip(")")).split(",")
      v1 = parsedEdge[0]
      v2 = parsedEdge[1]
      prefString = edgesDict[edge]
      print(f"{v1} {v2} {prefString}") #FOR TESTING
      f_out.write(f"{v1} {v2} {prefString}\n") #write the edge to the file

  #OUtPUT FILE CLOSED PAST THIS POINT
  return

"""# Convert Multiple Files"""

# Reads the metadata of a single XML file while updating any existing data from other files
# INPUT:
#     inputFilename: the name of the XML file to read the metadata from
#     varToId: dictionary mapping all variable names that exist thus far as keys to their IDs
#     varToEvals: dictionary mapping all variable names that exist thus far to a list of their possible domain values
# RETURN:
#     numPrefs: the updated total number of preference statements thus far
#     varToId: the updated dictionary of variable names to IDS
#     varToEvals: the updated dictionary of variable names to possible domain values
def getXmlMetadata(inputFilename, varToId, varToEvals):
  #READ INPUT FILE - put all the lines of the file into 'lines'
  with open(inputFilename, 'r') as file:
    lines = file.readlines()

  #INITIALIZE GLOBAL VARIABLES
  i = 0                     #keep track of the line of the file you are in
  numVariables = 0          #number of (assignable) variables in the preference graph
  numPrefs = 0              #number of preference statements

  # print(len(lines))

  #Parse Variable Data
  while i < len(lines):
    line = lines[i].strip()

    # Start of new variable
    if line == "<PREFERENCE-VARIABLE>":
      # Setup variables
      numVariables += 1
      i += 1
      variable = ""
      currVarNew = False         # If the current variable exists in a previous file
      possibleAssignments = []   # List of possible domain values for the current variable
      doneCurrVar = False        # Will be true once done with parsing current variable
      while not doneCurrVar:
        line = lines[i].strip()
        parts = line.split(">")
        # Store variable name
        if parts[0] == "<VARIABLE-NAME":
          variable = parts[1].split("<")[0]
          # If the variable does not already exist, add it to the list
          if not variable in varToId:
            varToId[variable] = len(varToId)
            currVarNew = True
          # Otherwise, get the list of existing domain values
          else:
            possibleAssignments = varToEvals[variable]
        # Add a possible variable domain value, if it does not already exist
        elif parts[0] == "<DOMAIN-VALUE":
          currVal = parts[1].split("<")[0]
          if currVarNew or not currVal in possibleAssignments:
            possibleAssignments.append(currVal)
        # End of current variable
        elif parts[0] == "</PREFERENCE-VARIABLE":
          varToEvals[variable] = possibleAssignments
          doneCurrVar = True
        # Move on to next line
        i += 1
    # Increase number of preference statements
    elif line == "<PREFERENCE-STATEMENT>":
      numPrefs += 1
      i += 1
    # Move on to next line
    else:
      i+=1

  print(varToEvals)
  print(varToId)
  return numPrefs, varToId, varToEvals


# Reads the preferences of a single XML file from a list of several different XML files
# INPUT:
#     inputFilename: name of the current file whose preferences are being read
#     varToId: dictionary mapping all variable names that exist thus far as keys to their IDs
#     assignmentToId: dictionary mapping all assignments/outcomes to their corresponding IDs
#     edgesDict: dictionary mapping all edges found thus far to a binary string representing which preferences induce said edge
#     numPrefs: total number of preferences across all input files
#     currPrefNum: number of preferences across all input files that have been processed thus far
# RETURNS:
#     edgesDict: updated dictionary of edges to binary string of preference statements
#     currPrefNum: updated number of preference statements that have been processed thus far
def readPreferences(inputFilename, varToId, assignmentToId, edgesDict, numPrefs, currPrefNum):
  #READ INPUT FILE - put all the lines of the file into 'lines'
  with open(inputFilename, 'r') as file:
    lines = file.readlines()

  currPrefId = -1             #variable to store the ID of the current preference statement we are looking at TODO: remove if we don't need it
  invVariableIds = []         #array to store the current invariant variables
  invVariableVals = []        #array to store the current invariant variables invariant values
  domOrder = []               #array to store the order of the dominance of the domain values
  relLessImpVarIDs = []       #array to store the current variables that are relatively less important
  i = 0                       #reset line tracker

  while i < len(lines):
    line = lines[i].strip()

    if line == "<PREFERENCE-STATEMENT>":
      i += 1
      doneCurrStatement = False
      firstDom = True
      varCurPrefOver = ""
      # Clear the previous preference statement data
      invVariableIds.clear()
      invVariableVals.clear()
      domOrder.clear()
      relLessImpVarIDs.clear()
      # Parse the statement
      while not doneCurrStatement:
        line = lines[i].strip()
        parts = line.split(">")
        # Read the preference ID
        if parts[0] == "<STATEMENT-ID":
          currPrefId = parts[1].split("<")[0]
        # Read the variable the preference is on
        elif parts[0] == "<PREFERENCE-VARIABLE":
          varCurrPrefOver = parts[1].split("<")[0]
        # Read the conditions of the statement
        elif parts[0] == "<CONDITION":
          currCond = parts[1].split("<")[0].split("=")
          invVariableIds.append(varToId[currCond[0]])
          invVariableVals.append(currCond[1])
        # Read the preference order of the statements
        elif parts[0] == "<PREFERENCE":
          currPrefOrder = parts[1].split("<")[0].split(":")
          # Note, this currently abuses the fact that the xml gives the dominance from most to least preferred values
          # Might want to change this in the future
          if firstDom:
            domOrder.append(currPrefOrder[0])
            firstDom = False
          domOrder.append(currPrefOrder[1])
        # Read the relatively less important variables
        elif parts[0] == "<REGARDLESS-OF":
          relLessImpVarIDs.append(varToId[parts[1].split("<")[0]])
          print(varToId[parts[1].split("<")[0]])
        # End of statement, can add to graph
        elif parts[0] == "</PREFERENCE-STATEMENT":
          doneCurrStatement = True
          #TODO: DEAL WITH END OF STATEMENT
          # Currently only works with binary values
          domVarId = varToId[varCurrPrefOver]  # get the ID of the variable in the dominance relation
          dominatingVal = domOrder[0]      # the dominating val is prefered over the dominated val
          dominatedVal = domOrder[1]

          for assignment in assignmentToId: #go through all the assignments and create edges for the edge file
            allInvariantsMatch = True   #keeps track on whether all the invariants are satisfied
            for j in range(0,len(invVariableIds)):
              if assignment[invVariableIds[j]] != invVariableVals[j]:
                allInvariantsMatch = False  #we saw an invariant that doesn't match
            if allInvariantsMatch and assignment[domVarId] == dominatingVal: #check if the invariant variables match and the domination relation variable is the dominating value
              #get the id of the dominating assignment
              dominatingAssignmentId = assignmentToId[assignment]

              #get the id of the dominated assignment
              dominatedAssignment = list(assignment)  #turn to list for mutability
              dominatedAssignment[domVarId] = dominatedVal #change the value of the domination varaible from dominating val to dominated val
              dominatedAssignment = ''.join(dominatedAssignment)  #turn back to a string
              # dominatedAssignmentId = assignmentToId[dominatedAssignment] #get the ID of the assignment

              dominatedAssignments = []
              getDominatedAssignments(assignmentToId, dominatedAssignments, dominatedAssignment, relLessImpVarIDs)
              # print("Dominated Assignments: ", dominatedAssignments)

              for dominatedAssignmentId in dominatedAssignments:

                #create edge
                newEdge = "(" + str(dominatingAssignmentId) + "," + str(dominatedAssignmentId) + ")" #NOTE this makes edge point towards dominating assignment: dominatedAssignment->dominatingAssignment
                print(newEdge)
                print(assignment,dominatedAssignment)

                if newEdge in edgesDict:  #if the edge has already been made previously, just update the stakeholder string
                  newPrefList = list(edgesDict[newEdge]) #make list for mutability
                  print(currPrefNum, newPrefList)
                  newPrefList[currPrefNum] = '1'    #make the current stakeholder be an endorser of this edge
                  newPrefStr = ''.join(newPrefList) #make string again
                  edgesDict[newEdge] = newPrefStr    #update dictionary
                else: #otherwise the edge is new so add a new entry to the dict where the only stakeholder endorsing this edge is the current one
                  newPrefStr = list('0'*numPrefs)  #turn to list for mutability
                  newPrefStr[currPrefNum] = '1'
                  newPrefStr = ''.join(newPrefStr)    #turn list back into string
                  edgesDict[newEdge] = newPrefStr
        # Continue to next line
        i += 1
        # print(i)
      print("Preference Statement " + str(currPrefNum) + " on variable ", varCurrPrefOver)
      print(invVariableIds)
      print(invVariableVals)
      print(domOrder)
      currPrefNum += 1
    #Move on to next line
    else:
      i += 1
      # print(i)

  return edgesDict, currPrefNum


# Convert a list of several XML Preference files into a single PFG file
# Used to combine several consistent CP-nets into one inconsistent one, as described in the "Data Set Generation" Section of the paper
# INPUT:
#     inputFileList: list of names of all the input files that will make up the CP-net
#     outputFile: name of the file to output the graph data to
# RETURN: nothing, prints and writes all graph data to the output file
def multiXmlPrefToPGFconverter(inputFileList, outputFile):

  edgesDict = {}
  numPrefs = 0
  varToId = {}
  varToEvals = {}
  assignmentToId = {}
  # Read and combine the metadata of all the files
  for inputFile in inputFileList:
    numPrefsCurrFile, varToId, varToEvals = getXmlMetadata(inputFile, varToId, varToEvals)
    numPrefs = numPrefs + numPrefsCurrFile

  numVariables = len(varToId)

  print(numPrefs, numVariables)

  #GENERATE ALL ASSIGNMENTS (all nodes of graph) in the assignmentToId dict
  fillAssignmentDict(assignmentToId, numVariables,  [1,2]) #TODO: instead of 0,1, this should take in a list of variable assignments based on the metadata parsed, probs varToEvals

  filePrefNum = 0

  for inputFile in inputFileList:
    edgesDict, filePrefNum = readPreferences(inputFile, varToId, assignmentToId, edgesDict, numPrefs, filePrefNum)
    print(filePrefNum, edgesDict)

  #DONE PARSING LINES, write all edges to output file
  with open(outputFile, 'w') as f_out:
    print(assignmentToId)
    for edge in edgesDict:
      parsedEdge = ((edge.strip("(")).strip(")")).split(",")
      v1 = parsedEdge[0]
      v2 = parsedEdge[1]
      prefString = edgesDict[edge]
      print(f"{v1} {v2} {prefString}") #FOR TESTING
      f_out.write(f"{v1} {v2} {prefString}\n") #write the edge to the file



"""# Convert CP-Net to CP-Theory"""

# Converts an XML file of a CP-net to an XML file of a CP-theory by randomly adding relatively less important variables to the preferences
# INPUTS:
#     inputFilename: name of the CP-net XML file to convert to a CP-theory
#     outputFilename: name of the output file to write the converted CP-theory into (in the XML format)
#     noRelLessImpProb: probability that a preference statement has no relatively less important variables and thus remains a CP-net statement, used as 0.5 for our data generation
# RETURN: nothing, prints and writes all graph data to the output file
def CPNetToCPTheoryConverter(inputFilename, outputFilename, noRelLessImpProb):
  #READ INPUT FILE - put all the lines of the file into 'lines'
  with open(inputFilename, 'r') as file:
    lines = file.readlines()

  #INITIALIZE GLOBAL VARIABLES
  i = 0                     #keep track of the line of the file you are in
  edgesDict = {}
  numVariables = 0          #number of (assignable) variables in the preference graph
  numPrefs = 0              #number of preference statements
  varToId = {}              #maps variables to int ID's which are used to index it
  assignmentToId = {}       #maps assignments of all variables (corresponding to nodes in graph) to integer IDs
  varToEvals = {}           #maps variable names ('v0') to possible assignments ([0,1,...])

  print(len(lines))

  #Parse Variable Data
  while i < len(lines):
    line = lines[i].strip()

    # Start of new variable
    if line == "<PREFERENCE-VARIABLE>":
      # Setup variables
      numVariables += 1
      i += 1
      variable = ""
      possibleAssignments = []
      doneCurrVar = False        # Will be true once done with parsing current variable
      while not doneCurrVar:
        line = lines[i].strip()
        parts = line.split(">")
        # Store variable name
        if parts[0] == "<VARIABLE-NAME":
          variable = parts[1].split("<")[0]
          varToId[variable] = numVariables - 1
        # Add a possible variable value
        elif parts[0] == "<DOMAIN-VALUE":
          currVal = parts[1].split("<")[0]
          possibleAssignments.append(currVal)
        # End of current variable
        elif parts[0] == "</PREFERENCE-VARIABLE":
          varToEvals[variable] = possibleAssignments
          doneCurrVar = True
        # Move on to next line
        i += 1
    # Increase number of preference statements
    elif line == "<PREFERENCE-STATEMENT>":
      numPrefs += 1
      i += 1
    # Move on to next line
    else:
      i+=1

  print(varToEvals)
  print(varToId)

  #PARSE PREFERENCES
  currPrefNum = -1
  currPrefId = -1             #variable to store the ID of the current preference statement we are looking at TODO: remove if we don't need it
  invVariableIds = []         #array to store the current invariant variables
  invVariableVals = []        #array to store the current invariant variables invariant values
  domOrder = []               #array to store the order of the dominance of the domain values
  relLessImpVarIDs = []       #array to store the current variables that are relatively less important
  i = 0                       #reset line tracker

  # Write the updated preference statements to the output file
  with open(outputFilename, 'w') as f_out:

    while i < len(lines):
      line = lines[i].strip()

      if line == "<PREFERENCE-STATEMENT>":
        f_out.write(lines[i])
        i += 1
        doneCurrStatement = False
        firstDom = True
        varCurrPrefOver = ""
        currPrefNum += 1
        # Clear the previous preference statement data
        invVariableIds.clear()
        invVariableVals.clear()
        domOrder.clear()
        relLessImpVarIDs.clear()
        # Parse the statement
        while not doneCurrStatement:
          line = lines[i].strip()
          parts = line.split(">")
          # Read the preference ID
          if parts[0] == "<STATEMENT-ID":
            currPrefId = parts[1].split("<")[0]
          # Read the variable the preference is on
          elif parts[0] == "<PREFERENCE-VARIABLE":
            varCurrPrefOver = parts[1].split("<")[0]
          # Read the conditions of the statement
          elif parts[0] == "<CONDITION":
            currCond = parts[1].split("<")[0].split("=")
            invVariableIds.append(varToId[currCond[0]])
            invVariableVals.append(currCond[1])
          # Read the preference order of the statements
          elif parts[0] == "<PREFERENCE":
            currPrefOrder = parts[1].split("<")[0].split(":")
            # Note, this currently abuses the fact that the xml gives the dominance from most to least preferred values
            # Might want to change this in the future
            if firstDom:
              domOrder.append(currPrefOrder[0])
              firstDom = False
            domOrder.append(currPrefOrder[1])
          # Read the relatively less important variables
          elif parts[0] == "<REGARDLESS-OF":
            relLessImpVarIDs.append(varToId[parts[1].split("<")[0]])
          # End of statement, can add to graph
          elif parts[0] == "</PREFERENCE-STATEMENT":
            doneCurrStatement = True
            # If there are no relatively less important variables, try and add some
            if len(relLessImpVarIDs) == 0:
              unusedVars = []
              # Find all unused variables
              for var, varId in varToId.items():
                if (not varId in invVariableIds) and (not var == varCurrPrefOver):
                  unusedVars.append(var)
              # print("Unused Variables: ", unusedVars)
              # Randomly decide whether to add the unused variables
              if noRelLessImpProb < 1 and not len(unusedVars) == 0:
                # Probability of adding a given variable
                # Ensures that the probability of a preference statement staying a CP-Net statement is the given probability
                addingVarProb = 1 - pow(noRelLessImpProb, 1/len(unusedVars))
                # print(1/len(unusedVars), addingVarProb)
                # Determine whether or not to add each unused variable as a relatively less important variable
                for unusedVar in unusedVars:
                  rolledProb = random.random()
                  if rolledProb < addingVarProb:
                    print("Added " + unusedVar + " as relatively less important variable")
                    f_out.write("  <REGARDLESS-OF>" + unusedVar + "</REGARDLESS-OF>\n")
                  print(rolledProb, addingVarProb)
          # Continue to next line
          f_out.write(lines[i])
          i += 1
          # print(i)
        print("Preference Statement on variable ", varCurrPrefOver)
        print(invVariableIds)
        print(invVariableVals)
        print(domOrder)
      #Move on to next line
      else:
        f_out.write(lines[i])
        i += 1
        # print(i)



# Converts an XML file of a CP-net to an XML file of a consistent CP-theory by randomly adding relatively less important variables to the preferences.
# Note that input CP-nets are required to be consistent and the generated CP-theories are fully acyclic, so there are consistent CP-theories that are not possible to be created.
# INPUTS:
#     inputFilename: name of the CP-net XML file to convert to a CP-theory
#     outputFilename: name of the output file to write the converted CP-theory into (in the XML format)
#     noRelLessImpProb: probability that a preference statement has no relatively less important variables and thus remains a CP-net statement, used as 0.5 for our data generation
# RETURN: nothing, prints and writes all graph data to the output file
def CPNetToConsistentCPTheoryConverter(inputFilename, outputFilename, noRelLessImpProb):
  #READ INPUT FILE - put all the lines of the file into 'lines'
  with open(inputFilename, 'r') as file:
    lines = file.readlines()

  #INITIALIZE GLOBAL VARIABLES
  i = 0                     #keep track of the line of the file you are in
  edgesDict = {}
  numVariables = 0          #number of (assignable) variables in the preference graph
  numPrefs = 0              #number of preference statements
  varToId = {}              #maps variables to int ID's which are used to index it
  assignmentToId = {}       #maps assignments of all variables (corresponding to nodes in graph) to integer IDs
  varToEvals = {}           #maps variable names ('v0') to possible assignments ([0,1,...])
  varToAncestors = {}

  print(len(lines))

  #Parse Variable Data
  while i < len(lines):
    line = lines[i].strip()

    # Start of new variable
    if line == "<PREFERENCE-VARIABLE>":
      # Setup variables
      numVariables += 1
      i += 1
      variable = ""
      possibleAssignments = []
      doneCurrVar = False        # Will be true once done with parsing current variable
      while not doneCurrVar:
        line = lines[i].strip()
        parts = line.split(">")
        # Store variable name
        if parts[0] == "<VARIABLE-NAME":
          variable = parts[1].split("<")[0]
          varToId[variable] = numVariables - 1
          varToAncestors[variable] = []
        # Add a possible variable value
        elif parts[0] == "<DOMAIN-VALUE":
          currVal = parts[1].split("<")[0]
          possibleAssignments.append(currVal)
        # End of current variable
        elif parts[0] == "</PREFERENCE-VARIABLE":
          varToEvals[variable] = possibleAssignments
          doneCurrVar = True
        # Move on to next line
        i += 1
    # Increase number of preference statements
    elif line == "<PREFERENCE-STATEMENT>":
      numPrefs += 1
      i += 1
      doneCurrStatement = False
      currAncestors = []
      varCurrPrefOver = ""
      while not doneCurrStatement:
          line = lines[i].strip()
          parts = line.split(">")
          if parts[0] == "<PREFERENCE-VARIABLE":
            varCurrPrefOver = parts[1].split("<")[0]
            currAncestors = varToAncestors[varCurrPrefOver]
          elif parts[0] == "<CONDITION":
            currCond = parts[1].split("<")[0].split("=")
            if not currCond[0] in currAncestors:
              currAncestors.append(currCond[0])
          elif parts[0] == "</PREFERENCE-STATEMENT":
            doneCurrStatement = True
            varToAncestors[varCurrPrefOver] = currAncestors
          i += 1
    # Move on to next line
    else:
      i+=1

  print(varToEvals)
  print(varToId)
  print("Parent Dictionary:", varToAncestors)

  newChanges = True
  while newChanges:
    newChanges = False
    for var in varToAncestors.keys():
      existingAncestors = varToAncestors[var]
      for knownAncestor in existingAncestors:
        for possibleAncestor in varToAncestors[knownAncestor]:
          if not possibleAncestor in existingAncestors:
            existingAncestors.append(possibleAncestor)
            newChanges = True

  print("Ancestor Dictionary:", varToAncestors)

  # ancestors = varToAncestors.items()
  # print("Parent List:", ancestors)
  # ancestors = sorted(ancestors, key= lambda var: len(var[1]))
  # print("Parent List:", ancestors)

  #PARSE PREFERENCES
  currPrefNum = -1
  currPrefId = -1             #variable to store the ID of the current preference statement we are looking at TODO: remove if we don't need it
  invVariableIds = []         #array to store the current invariant variables
  invVariableVals = []        #array to store the current invariant variables invariant values
  domOrder = []               #array to store the order of the dominance of the domain values
  relLessImpVarIDs = []       #array to store the current variables that are relatively less important
  i = 0                       #reset line tracker

  # Write the updated preference statements to the output file
  with open(outputFilename, 'w') as f_out:

    while i < len(lines):
      line = lines[i].strip()

      if line == "<PREFERENCE-STATEMENT>":
        f_out.write(lines[i])
        i += 1
        doneCurrStatement = False
        firstDom = True
        varCurrPrefOver = ""
        currPrefNum += 1
        # Clear the previous preference statement data
        invVariableIds.clear()
        invVariableVals.clear()
        domOrder.clear()
        relLessImpVarIDs.clear()
        # Parse the statement
        while not doneCurrStatement:
          line = lines[i].strip()
          parts = line.split(">")
          # Read the preference ID
          if parts[0] == "<STATEMENT-ID":
            currPrefId = parts[1].split("<")[0]
          # Read the variable the preference is on
          elif parts[0] == "<PREFERENCE-VARIABLE":
            varCurrPrefOver = parts[1].split("<")[0]
          # Read the conditions of the statement
          elif parts[0] == "<CONDITION":
            currCond = parts[1].split("<")[0].split("=")
            invVariableIds.append(varToId[currCond[0]])
            invVariableVals.append(currCond[1])
          # Read the preference order of the statements
          elif parts[0] == "<PREFERENCE":
            currPrefOrder = parts[1].split("<")[0].split(":")
            # Note, this currently abuses the fact that the xml gives the dominance from most to least preferred values
            # Might want to change this in the future
            if firstDom:
              domOrder.append(currPrefOrder[0])
              firstDom = False
            domOrder.append(currPrefOrder[1])
          # Read the relatively less important variables
          elif parts[0] == "<REGARDLESS-OF":
            relLessImpVarIDs.append(varToId[parts[1].split("<")[0]])
          # End of statement, can add to graph
          elif parts[0] == "</PREFERENCE-STATEMENT":
            doneCurrStatement = True
            # If there are no relatively less important variables, try and add some
            if len(relLessImpVarIDs) == 0:
              unusedVars = []
              # Find all unused variables
              for var, varId in varToId.items():
                if (not varId in invVariableIds) and (not var == varCurrPrefOver) and (not var in varToAncestors[varCurrPrefOver]):
                  unusedVars.append(var)
              # print("Unused Variables: ", unusedVars)
              # Randomly decide whether to add the unused variables
              if noRelLessImpProb < 1 and not len(unusedVars) == 0:
                # Probability of adding a given variable
                # Ensures that the probability of a preference statement staying a CP-Net statement is the given probability
                addingVarProb = 1 - pow(noRelLessImpProb, 1/len(unusedVars))
                # print(1/len(unusedVars), addingVarProb)
                # Determine whether or not to add each unused variable as a relatively less important variable
                for unusedVar in unusedVars:
                  rolledProb = random.random()
                  if rolledProb < addingVarProb:
                    print("Added " + unusedVar + " as relatively less important variable to pref on " + varCurrPrefOver)
                    f_out.write("  <REGARDLESS-OF>" + unusedVar + "</REGARDLESS-OF>\n")
                  # print(rolledProb, addingVarProb)
          # Continue to next line
          f_out.write(lines[i])
          i += 1
          # print(i)
        # print("Preference Statement on variable ", varCurrPrefOver)
        # print(invVariableIds)
        # print(invVariableVals)
        # print(domOrder)
      #Move on to next line
      else:
        f_out.write(lines[i])
        i += 1
        # print(i)




"""# MAIN"""

###### MAIN #####

# xmlPrefFileToPGFconverter("cpnet_n3c2d2_0000.xml","PFG1")

# CPNetToCPTheoryConverter("cpnet_n3c2d2_0000.xml", "cptheory_n3c2d2_p50_0000.xml", 0.5)
# CPNetToCPTheoryConverter("cpnet_n3c2d2_0001.xml", "cptheory_n3c2d2_p50_0001.xml", 0.5)
# CPNetToCPTheoryConverter("cpnet_n3c2d2_0002.xml", "cptheory_n3c2d2_p50_0002.xml", 0.5)

# CPNetToConsistentCPTheoryConverter("cpnet_n7c5d2_0000.xml", "cptheory_n3c2d2_p50_0000.xml", 0.5)

# multiXmlPrefToPGFconverter(["cptheory_n8c5d2_p50_0000.xml", "cptheory_n8c5d2_p50_0001.xml", "cptheory_n8c5d2_p50_0002.xml"], "cptheory-n8d2g3p50-PFG3.txt")